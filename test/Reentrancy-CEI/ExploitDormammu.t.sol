// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test} from "forge-std/Test.sol";
import {DormammuTreasuryVulnerable} from "../../src/Reentrancy-CEI/DormammuTreasuryVulnerable.sol";
import {DormammuTreasuryFixed} from "../../src/Reentrancy-CEI/DormammuTreasuryFixed.sol";
import {TimeStone} from "../../src/Reentrancy-CEI/TimeStone.sol";

contract ReentrancyDormammuTest is Test {
    DormammuTreasuryVulnerable treasury;
    DormammuTreasuryFixed fixedTreasury;
    TimeStone stone;
    TimeStone timeStoneFixed;

    address public Doctor_Strange = makeAddr("Doctor Strange");

    function setUp() public {
        // Deploy vulnerable and fixed contracts
        treasury = new DormammuTreasuryVulnerable();
        fixedTreasury = new DormammuTreasuryFixed();

        // Fund the Dormammu treasury (other citizens)
        vm.deal(address(this), 50 ether);
        // send 20 ETH to vulnerable treasury as "Alien citizen deposits"
        treasury.deposit{value: 20 ether}();
        fixedTreasury.deposit{value: 20 ether}();

        // deploy stone and fund it
        vm.prank(Doctor_Strange);
        stone = new TimeStone(address(treasury));
        vm.deal(address(Doctor_Strange), 5 ether);

        vm.prank(Doctor_Strange);
        timeStoneFixed = new TimeStone(address(fixedTreasury));
    }

    function test_Strange_Drains_Dormammu_With_TimeStone() public {
        // Check initial balances
        uint256 initialTreasury = address(treasury).balance;
        assertEq(initialTreasury, 20 ether);

        // Doctor Strange: Doctor Strange deposits 1 ETH and triggers reentrancy withdraw
        vm.prank(Doctor_Strange);
        stone.attack{value: 1 ether}();

        // After attack collect to track funds in This Contract (optional)
        vm.prank(Doctor_Strange);
        stone.collect();

        // Doctor Strange should have profit (>1 ETH)
        // Dormammu Treasury should NOT have its full 20 ETH anymore
        uint256 remainingTreasury = address(treasury).balance;
        assertLt(remainingTreasury, 20 ether, "Dormammu Treasury should have lost funds due to reentrancy");
    }

    /// @notice Minimal test reusing vulnerable pattern but targeting fixed contract type
    function test_Fixed_Resists_Reentrancy() public {
        // Check initial balances
        uint256 initialTreasury = address(fixedTreasury).balance;
        assertEq(initialTreasury, 20 ether);

        // Doctor Strange tries to attack fixed treasury
        vm.prank(Doctor_Strange);
        vm.expectRevert(); // we EXPECT this to fail
        timeStoneFixed.attack{value: 1 ether}();

        // Verify treasury still holds full funds
        uint256 remainingfixedTreasury = address(fixedTreasury).balance;
        assertEq(remainingfixedTreasury, 20 ether, "Fixed treasury should resist reentrancy and keep full funds");
    }
}
